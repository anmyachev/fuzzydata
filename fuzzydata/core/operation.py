import logging
import time
from abc import ABC, abstractmethod
from typing import List, TypeVar, Generic, Dict

from fuzzydata.core.artifact import Artifact

T = TypeVar('T')

logger = logging.getLogger(__name__)


class Operation(Generic[T], ABC):

    def __init__(self, sources: List[Artifact], new_label: str):
        self.sources = sources
        self.new_label = new_label
        self.dest_schema_map = None

        # Operation Timings
        self.start_time = None
        self.end_time = None

        # Code Generation Variables
        self.code = 'self.sources[0].table'
        self.current_schema_map = self.sources[0].schema_map
        self.num_operations = 0
        self.op_list = []  # List[Dict] of op names and args to chain together.

    def add_source_artifact(self, s_artifact: Artifact) -> None:
        self.sources.append(s_artifact)

    @abstractmethod
    def sample(self, frac: float) -> T:
        self.current_schema_map = self.current_schema_map
        pass

    @abstractmethod
    def apply(self, numeric_col: str, a: float, b: float) -> T:
        self.current_schema_map = self.current_schema_map
        self.current_schema_map[f"{numeric_col}__{a}x_{b}"] = self.current_schema_map[numeric_col]
        pass

    @abstractmethod
    def groupby(self, group_columns: List[str], agg_columns: List[str], agg_function: str) -> T:
        output_cols = list(group_columns) + list(agg_columns)
        self.current_schema_map = dict(filter(lambda x: x[0] in output_cols, self.current_schema_map.items()))
        pass

    @abstractmethod
    def project(self, output_cols: List[str]) -> T:
        self.current_schema_map = dict(filter(lambda x: x[0] in output_cols, self.current_schema_map.items()))
        pass

    @abstractmethod
    def select(self, condition: str) -> T:
        self.current_schema_map = self.current_schema_map
        pass

    @abstractmethod
    def merge(self, key_col: List[str]) -> T:  # TODO: add secondary source for merge
        self.current_schema_map = {**self.current_schema_map, **self.sources[1].schema_map}
        pass

    @abstractmethod
    def pivot(self, index_cols: List[str], columns: List[str], value_col: List[str], agg_func: str) -> T:
        # Destination Schema Map should be generated by operation!
        # TODO: prevent further op generation after this point since we MUST materialize.
        pass

    @abstractmethod
    def fill(self, col_name: str, old_value, new_value) -> T:
        # Destination Schema Map should be generated by operation!
        self.current_schema_map = self.current_schema_map
        pass

    @abstractmethod
    def chain_operation(self, op, args):
        """
        :param op: string label of operation to chain
        :param args: arguments of the operation to chain
        :return: None
        """
        """ Take the current operation information stored and generate the code to be chained. 
            Assume self.code is updated here by the client implementation, so basically, this just updates
            the op_list metadata. client implementation super() class should be AFTER code is generated. """
        self.op_list.append({'op': op, 'args': args})
        self.num_operations += 1


    @abstractmethod
    def materialize(self):
        """ python eval() or sql.execute to be called on self.code here
        Must return Artifact of same class after running operation
        TODO: Explore the difference between this and execute() """

    def execute(self) -> None:
        logger.debug(f"Before Op: {self.sources[0].to_df().columns}")
        logger.debug(f"Operation Code: {self.code}")
        self.start_time = time.perf_counter()
        result = self.materialize()
        self.end_time = time.perf_counter()
        logger.debug(f"After Op: {result.to_df()}")
        return result

    def get_execution_time(self):
        return self.end_time - self.start_time

    def to_dict(self) -> dict:
        return {
            'sources': [s.label for s in self.sources],
            'new_label': self.new_label,
            'op_list': self.op_list,
        }
